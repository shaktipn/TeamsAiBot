package com.suryadigital.teamsaibot.teamsMeeting.websockets

import com.suryadigital.leo.inlineLogger.getInlineLogger
import io.ktor.server.routing.Route
import io.ktor.server.routing.get
import io.ktor.server.websocket.DefaultWebSocketServerSession
import io.ktor.server.websocket.webSocket
import io.ktor.websocket.CloseReason
import io.ktor.websocket.Frame
import io.ktor.websocket.close
import io.ktor.websocket.readText
import kotlinx.coroutines.delay
import java.time.Instant
import java.util.UUID

private val logger = getInlineLogger()

fun Route.getSummary() {
    webSocket("echo") {
        send(Frame.Text("Please enter your name"))
        for (frame in incoming) {
            frame as? Frame.Text ?: continue
            val receivedText = frame.readText()
            if (receivedText.equals("bye", ignoreCase = true)) {
                close(CloseReason(CloseReason.Codes.NORMAL, "Client said BYE"))
            } else {
                send(Frame.Text("Hi, $receivedText!"))
            }
        }
    }

    webSocket("get-summary") {
        send(Frame.Text("conn"))
        val sessionIdParam = call.request.queryParameters["sessionId"]
        send(Frame.Text(sessionIdParam.toString()))

        val sessionId = sessionIdParam?.let(UUID::fromString)

        if (sessionId == null) {
            close(
                reason =
                    CloseReason(
                        code = CloseReason.Codes.CANNOT_ACCEPT,
                        message = "Missing or invalid 'sessionId'",
                    ),
            )
            return@webSocket
        }

        // 3. Log / store the sessionId
        logger.info { "WebSocket connected for sessionId=$sessionId" }

        // 4. Use helper to continuously send messages
        sendContinuously {
            // The lambda generates the text to send
            generateSummaryText(sessionId)
        }
    }
}

/**
 * Helper to continuously send text frames generated by a suspend lambda.
 * If the lambda throws or send fails â†’ close the WebSocket.
 */
suspend fun DefaultWebSocketServerSession.sendContinuously(messageSupplier: suspend () -> String) {
    try {
        while (true) {
            val text = messageSupplier()
            outgoing.send(Frame.Text(text))
        }
    } catch (e: Throwable) {
        // Log, cleanup, and close socket
        logger.error(e) { "Error while sending WebSocket messages: ${e.message}" }
        close(
            CloseReason(
                CloseReason.Codes.INTERNAL_ERROR,
                "Error generating messages",
            ),
        )
    }
}

suspend fun generateSummaryText(sessionId: UUID): String {
    delay(2000) // Simulate work
    return "Summary update for session: $sessionId at ${Instant.now()}"
}
